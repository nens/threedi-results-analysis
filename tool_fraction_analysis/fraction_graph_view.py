from qgis.core import Qgis
from qgis.core import QgsFeature
from qgis.core import QgsFeatureRequest
from qgis.core import QgsProject
from qgis.core import QgsValueMapFieldFormatter
from qgis.core import QgsVectorLayer
from qgis.core import QgsWkbTypes
from qgis.gui import QgsRubberBand
from qgis.PyQt.QtCore import pyqtSlot
from qgis.PyQt.QtCore import QSize
from qgis.PyQt.QtCore import Qt
from qgis.PyQt.QtWidgets import QCheckBox
from qgis.PyQt.QtWidgets import QComboBox
from qgis.PyQt.QtWidgets import QHBoxLayout
from qgis.PyQt.QtWidgets import QMessageBox
from qgis.PyQt.QtWidgets import QSizePolicy
from qgis.PyQt.QtWidgets import QSpacerItem
from qgis.PyQt.QtWidgets import QSplitter
from qgis.PyQt.QtWidgets import QVBoxLayout
from qgis.PyQt.QtWidgets import QWidget
from threedi_results_analysis.datasource.threedi_results import normalized_object_type
from threedi_results_analysis.threedi_plugin_model import ThreeDiPluginModel
from threedi_results_analysis.threedi_plugin_model import ThreeDiResultItem
from threedi_results_analysis.tool_fraction_analysis.fraction_model import FractionModel
from threedi_results_analysis.tool_fraction_analysis.fraction_plot import FractionPlot
from threedi_results_analysis.tool_fraction_analysis.fraction_table import FractionTable
from threedi_results_analysis.utils.constants import TOOLBOX_MESSAGE_TITLE
from threedi_results_analysis.utils.user_messages import messagebar_message
from threedi_results_analysis.utils.user_messages import statusbar_message
from typing import List

import logging


logger = logging.getLogger(__name__)


def is_threedi_node_cell_layer(vector_layer: QgsVectorLayer) -> bool:
    """
    Checks whether a layer has been generated by the 3Di toolbox.

    It is an extensive check, trying to be backwards compatible with older tools.
    """
    if not vector_layer:
        return False

    if vector_layer.objectName() in ("node", "cell"):
        return True

    return False

class FractionWidget(QWidget):
    def __init__(
        self,
        parent,
        model: ThreeDiPluginModel,
        parameter_config,
        iface
    ):
        super().__init__(parent)

        self.model = model
        self.parent = parent
        self.iface = iface

        self.setup_ui()

        self.fraction_model = FractionModel(self, self.model)
        self.graph_plot.set_fraction_model(self.fraction_model)
        self.graph_plot.set_result_model(self.model)
        self.fraction_table.setModel(self.fraction_model)
        
        # set listeners
        self.ts_units_combo_box.currentIndexChanged.connect(self.time_units_change)
        self.fraction_table.deleteRequested.connect(self._removeRows)

        self.marker = QgsRubberBand(self.iface.mapCanvas())
        self.marker.setColor(Qt.red)
        self.marker.setWidth(2)

    def _removeRows(self, index_list):
        # Also here, remove in decreasing order to keep table idx valid
        row_list = [index.row() for index in index_list]
        row_list.sort(reverse=True)
        for row in row_list:
            self.fraction_model.removeRows(row, 1)

    def refresh_table(self):
        # trigger all listeners by emiting dataChanged signal
        self.fraction_model.beginResetModel()
        self.fraction_model.endResetModel()
        self.fraction_table._update_table_widgets()

    @pyqtSlot(ThreeDiResultItem)
    def result_removed(self, result_item: ThreeDiResultItem):
        # Remove corresponding plots that refer to this item
        item_idx_to_remove = []
        for count, item in enumerate(self.fraction_model.rows):
            if item.result.value is result_item:
                item_idx_to_remove.append(count)

        # We delete them descending to keep the row idx consistent
        for item_idx in reversed(item_idx_to_remove):
            self.fraction_model.removeRows(item_idx, 1)

    def closeEvent(self, event):
        """
        overwrite of QDockWidget class to emit signal
        :param event: QEvent
        """
        self.on_close()
        event.accept()

    def highlight_feature(self, obj_id, obj_type, result_item: ThreeDiResultItem):

        for table_name, layer_id in result_item.parent().layer_ids.items():

            if obj_type == table_name:
                # query layer for object
                filt = u'"id" = {0}'.format(obj_id)
                request = QgsFeatureRequest().setFilterExpression(filt)
                lyr = QgsProject.instance().mapLayer(layer_id)
                features = lyr.getFeatures(request)
                for feature in features:
                    self.marker.setToGeometry(feature.geometry(), lyr)

    def unhighlight_all_features(self):
        """Remove the highlights from all layers"""
        self.marker.reset()

    def setup_ui(self):

        mainLayout = QHBoxLayout(self)
        self.setLayout(mainLayout)

        splitterWidget = QSplitter(self)

        # add plot
        self.graph_plot = FractionPlot(self)
        sizePolicy = QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(1)
        sizePolicy.setVerticalStretch(1)
        sizePolicy.setHeightForWidth(self.graph_plot.sizePolicy().hasHeightForWidth())
        self.graph_plot.setSizePolicy(sizePolicy)
        self.graph_plot.setMinimumSize(QSize(250, 250))
        splitterWidget.addWidget(self.graph_plot)

        # add widget for timeseries table and other controls
        legendWidget = QWidget(self)
        vLayoutTable = QVBoxLayout(self)
        legendWidget.setLayout(vLayoutTable)

        # add comboboxes
        self.ts_units_combo_box = QComboBox(self)
        self.ts_units_combo_box.insertItems(0, ["hrs", "mins", "s"])
        vLayoutTable.addWidget(self.ts_units_combo_box)
        vLayoutTable.setMargin(0)

        # add timeseries table
        self.fraction_table = FractionTable(self)
        self.fraction_table.hoverEnterRow.connect(self.highlight_feature)
        self.fraction_table.hoverExitAllRows.connect(self.unhighlight_all_features)
        sizePolicy = QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.fraction_table.sizePolicy().hasHeightForWidth())
        self.fraction_table.setSizePolicy(sizePolicy)
        self.fraction_table.setMinimumSize(QSize(250, 0))
        vLayoutTable.addWidget(self.fraction_table)
        splitterWidget.addWidget(legendWidget)
        mainLayout.addWidget(splitterWidget)
        mainLayout.setContentsMargins(0, 0, 0, 0)


    def time_units_change(self):
        time_units = self.ts_units_combo_box.currentText()
        self.graph_plot.setLabel("bottom", "Time", time_units)
        self.graph_plot.set_parameter(self.current_parameter, time_units)
        self.graph_plot.plotItem.vb.menu.viewAll.triggered.emit()

    def get_feature_index(self, layer, feature):
        """
        get the id of the selected id feature
        :param layer: selected Qgis layer to be added
        :param feature: selected Qgis feature to be added
        :return: idx (integer)
        We can't do ``feature.id()``, so we have to pick something that we
        have agreed on. For now we have hardcoded the 'id' field as the
        default, but that doesn't mean it's always the case in the future
        when more layers are added!
        """
        idx = feature.id()
        if layer.dataProvider().name() in ["memory", "ogr"]:
            idx = feature["id"]
        return idx

    def get_object_name(self, layer, feature):
        """
        get the object_name (display_name / type)  of the selected id feature
        :param layer: selected Qgis layer to be added
        :param feature: selected Qgis feature to be added
        :return: object_name (string)
        To get a object_name we use the following logic:
        - get the 'display_name' column if available;
        - if not: get the 'type' column if available;
        - if not: get the 'line_type' column if available;
        - if not: get the 'node_type' column if available;
        - if not: object_name = 'N/A'
        """
        for column_nr, field in enumerate(layer.fields()):
            if "display_name" in field.name():
                return feature[column_nr]
        for column_nr, field in enumerate(layer.fields()):
            if field.name() == "type":
                return feature[column_nr]

        # Apply ValueMap field formatter
        for column_nr, field in enumerate(layer.fields()):
            if field.name() == "line_type":
                config = layer.editorWidgetSetup(column_nr).config()
                return QgsValueMapFieldFormatter().representValue(layer, column_nr, config, None, feature[column_nr])
        for column_nr, field in enumerate(layer.fields()):
            if field.name() == "node_type":
                config = layer.editorWidgetSetup(column_nr).config()
                return QgsValueMapFieldFormatter().representValue(layer, column_nr, config, None, feature[column_nr])

        logger.warning("Layer has no 'display_name', it's probably a result "
                       "layer, but putting a placeholder object name just "
                       "for safety."
                       )

        return "N/A"

    def set_fraction(self, layer: QgsVectorLayer, feature: QgsFeature) -> bool:
        """
        :param layer: layer of features
        :param feature: Qgis layer feature to be added
        :return: boolean: new objects are added
        """

        if not is_threedi_node_cell_layer(layer):
            msg = """Please select results from either the 'nodes' or 'cells' layer."""
            messagebar_message(TOOLBOX_MESSAGE_TITLE, msg, Qgis.Warning, 5.0)
            return False

        if len(self.model.get_results(checked_only=False)) == 0:
            logger.warning("No results loaded")
            return False

        # Retrieve summary of existing items in model (!= graph plots)
        existing_items = [
            f"{item.object_type.value}_{str(item.object_id.value)}_{item.result.value.id}" for item in self.fraction_model.rows
        ]

        new_idx = self.get_feature_index(layer, feature)
        new_object_name = self.get_object_name(layer, feature)

        result_items = self.model.get_results(checked_only=False)
        for result_item in result_items:
            # Check whether this result belongs to the selected grid
            assert layer.id() in result_item.parent().layer_ids.values()

            # Check whether a node isn't already plotted as cell or vice versa (QGIS doesn't know they are the same thing)
            if layer.objectName() == "cell":
                if ("node_" + str(new_idx) + "_" + result_item.id) in existing_items:
                    logger.error("Cell already plotted as node item")
                    continue
            elif layer.objectName() == "node":
                if ("cell_" + str(new_idx) + "_" + result_item.id) in existing_items:
                    # Assert whether this is a 2D node
                    assert new_object_name.startswith("2D")
                    logger.error("Node already plotted as cell item")
                    continue

            if (layer.objectName() + "_" + str(new_idx) + "_" + result_item.id) not in existing_items:
                item = {
                    "object_type": layer.objectName(),
                    "object_id": new_idx,
                    "object_name": new_object_name,
                    "object_label": f"{result_item.parent().text()} | {result_item.text()} | ID: {new_idx}",
                    "result": result_item,
                    "color": self.fraction_model.get_color(new_idx, layer.id()),
                }
                new_items.append(item)


        # self.fraction_model.insertRows(new_items)
        # msg = "%i new objects added to plot " % len(new_items)
        # skipped_items = len(features) - len(new_items)
        # if skipped_items > 0:
        #     msg += "(skipped %s already present objects)" % skipped_items

        statusbar_message(msg)
        return True

    def remove_objects_table(self):
        """
        removes selected objects from table
        :return:
        """
        selection_model = self.fraction_table.selectionModel()
        # get unique rows in selected fields
        rows = set([index.row() for index in selection_model.selectedIndexes()])
        for row in reversed(sorted(rows)):
            self.fraction_model.removeRows(row, 1)